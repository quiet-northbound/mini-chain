M4 + M5 Spec (1 trang) — Build-a-Mini-Layer2 (Source of Truth)
1) Mục tiêu (M4 + M5)

M4 (Base Chain nâng cấp): chuẩn hoá block + chain history, validate/apply tx, bảo toàn state (balance/nonce), phát hiện lỗi nền tảng.

M5 (Mini Layer2 giả lập): xử lý tx off-chain, gom batch, tạo commit/summary về L1 để L1 lưu “dấu vết” lịch sử (không làm ZK/FRI, chỉ mô phỏng).

2) Data model tối thiểu
Account

address: string

balance: ulong

nonce: ulong (nonce kế tiếp hợp lệ)

pubKey?: string (tuỳ chọn cho mock)

lastUpdatedBlockHeight?: ulong (tuỳ chọn)

Tx

txId: string (hash deterministic từ nội dung tx, dùng để anti-replay)

from: string

to: string

amount: ulong

nonce: ulong

chainId: string

signature: string (mock)

createdAt: long (epoch ms)

Mock signature rule (chuẩn hoá): signature = "SIG(" + from + "|" + to + "|" + amount + "|" + nonce + "|" + chainId + ")"

Ledger / State

accounts: Map<address, Account>

seenTxIds: Set<string> (anti-replay toàn chain)

appliedTxHistory: List<TxReceipt> (hoặc per-block)

l2Commits: List<L2Commit> (M5)

TxReceipt

txId, status, failureReason?, blockHeight, stateRootAfter? (mock), timestamp

L2Commit (M5)

commitId: string

batchId: string

l2StateRoot: string (mock)

txCount: int

txIds: List<string> (tuỳ chọn, có thể chỉ lưu hash list)

submittedAtBlockHeight: ulong

Block

height: ulong

prevHash: string

timestamp: long

txs: List<Tx>

txReceipts: List<TxReceipt>

stateRoot: string (mock hash của state sau khi apply)

hash: string

Mock stateRoot/hash: có thể dùng hash của chuỗi serialize đã sort key để deterministic.

3) Flow xử lý chuẩn (L1 — áp dụng cho M4; M5 gọi vào L1 khi “commit”)
3.1 create tx

Input: from, to, amount, nonce

Tạo Tx với chainId

Tính txId = HASH(from|to|amount|nonce|chainId) (deterministic)

3.2 sign (mock)

Gán signature = SIG(from|to|amount|nonce|chainId)

3.3 validate

Check theo thứ tự (fail-fast):

ChainId đúng

Signature đúng (mock verify)
signature == expectedMockSig(tx)

Replay: tx.txId chưa tồn tại trong ledger.seenTxIds

Account tồn tại (auto-create với balance=0 nonce=0 nếu muốn, nhưng phải nhất quán)

Nonce đúng: tx.nonce == accounts[from].nonce

Sufficient balance: accounts[from].balance >= tx.amount

amount > 0 và from != to (tuỳ chọn nhưng nên có)

3.4 apply

accounts[from].balance -= amount

accounts[to].balance += amount

accounts[from].nonce += 1

3.5 update nonce/balance

Đã nằm trong apply (atomic trong 1 critical section / single-thread)

Nếu muốn “state snapshot”: tính stateRoot

3.6 append history

ledger.seenTxIds.add(txId)

Tạo TxReceipt(status=SUCCESS, blockHeight=currHeight, ...)

Append vào block.txReceipts và/hoặc ledger.appliedTxHistory

3.7 block/chain history (M4)

Gom tx vào Block(height=prev.height+1, prevHash=prev.hash, ...)

block.hash = HASH(blockHeader + stateRoot + txIds...)

Append block vào chain: List<Block>

4) M5: Layer2 giả lập (tối thiểu)

L2 mempool nhận tx (giống create/sign/validate sơ bộ).

Execute off-chain: apply vào l2State (cùng rules nonce/balance như L1, hoặc subset).

Batcher: mỗi N tx (hoặc theo timer) tạo batchId, l2StateRoot(mock), commitId.

Submit commit to L1: L1 nhận một “commit tx” (hoặc API riêng) để append L2Commit vào ledger.l2Commits + ghi vào block history.

L1 không cần verify cryptography, chỉ lưu “dấu vết” + tham chiếu batch/txCount/roots.

5) 5 test scenarios (happy path + lỗi nền tảng)
(1) Happy path: transfer hợp lệ

Given: A(balance=100, nonce=0), B(balance=0)
When: tx(A→B, amount=10, nonce=0) sign mock, validate/apply
Then: A(balance=90, nonce=1), B(balance=10), receipt SUCCESS, seenTxIds có txId, block height tăng, prevHash nối đúng.

(2) Nonce sai

Given: A(balance=100, nonce=1)
When: tx(A→B, amount=10, nonce=0)
Then: validate fail INVALID_NONCE, state không đổi, txId không add vào seenTxIds, receipt FAILED (nếu bạn vẫn ghi receipt) hoặc không ghi tuỳ design (nhưng nên deterministic).

(3) Thiếu balance

Given: A(balance=5, nonce=0)
When: tx(A→B, amount=10, nonce=0)
Then: fail INSUFFICIENT_BALANCE, state không đổi, nonce không tăng.

(4) Chữ ký mock sai

Given: tx đúng fields nhưng signature bị sửa
When: validate
Then: fail INVALID_SIGNATURE, state không đổi.

(5) Replay tx + chain history

Given: đã apply tx1 thành công (txId=X) ở block H
When: gửi lại đúng tx1 (cùng fields → cùng txId)
Then: fail REPLAY_TX
And chain history: block mới phải có prevHash == hash(block H); verify toàn chain: duyệt blocks, mỗi block.prevHash khớp hash block trước, height tăng 1 đều, không “đứt” lịch sử.

6) Invariants (điều kiện luôn đúng)

nonce của account chỉ tăng khi tx thành công.

Tổng balance toàn hệ (nếu chỉ transfer) không đổi.

Mỗi txId chỉ được apply tối đa 1 lần trong toàn chain.

Chain history không đứt: (height, prevHash) liên kết chính xác.

Nếu bạn muốn, mình có thể viết luôn pseudo-code Validate/Apply và format FailureReason enum chuẩn để bạn copy vào project.