# M4 + M5 Spec ‚Äî Layer 2 Executor + Commit to L1

> **Status**: üî≤ Ch∆∞a implement

---

## 1) M·ª•c ti√™u

| Milestone | M√¥ t·∫£ |
|-----------|--------|
| **M4** | Chu·∫©n ho√° block + chain history, validate/apply tx, b·∫£o to√†n state, ph√°t hi·ªán l·ªói n·ªÅn t·∫£ng |
| **M5** | Mini Layer2 gi·∫£ l·∫≠p: x·ª≠ l√Ω tx off-chain, gom batch, t·∫°o commit/summary v·ªÅ L1 |

> ‚ö†Ô∏è Kh√¥ng l√†m ZK/FRI ‚Äî ch·ªâ m√¥ ph·ªèng lu·ªìng rollup.

---

## 2) Data Model

### Account

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `address` | string | ƒê·ªãnh danh t√†i kho·∫£n |
| `balance` | ulong | S·ªë d∆∞ coin g·ªëc |
| `nonce` | ulong | Nonce k·∫ø ti·∫øp h·ª£p l·ªá |
| `pubKey` | string? | *(tu·ª≥ ch·ªçn)* Cho mock signature |
| `lastUpdatedBlockHeight` | ulong? | *(tu·ª≥ ch·ªçn)* |

### Transaction

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `txId` | string | `HASH(from\|to\|amount\|nonce\|chainId)` ‚Äî deterministic |
| `from` | string | Ng∆∞·ªùi g·ª≠i |
| `to` | string | Ng∆∞·ªùi nh·∫≠n |
| `amount` | ulong | S·ªë ti·ªÅn |
| `nonce` | ulong | Nonce k·ª≥ v·ªçng |
| `chainId` | string | ƒê·ªãnh danh chain |
| `signature` | string | Mock signature |
| `createdAt` | long | Epoch ms |

**Mock signature (chu·∫©n ho√°):**
```
signature = "SIG(" + from + "|" + to + "|" + amount + "|" + nonce + "|" + chainId + ")"
```

### Ledger / State

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `accounts` | `Map<address, Account>` | B·∫£n ƒë·ªì t√†i kho·∫£n |
| `seenTxIds` | `Set<string>` | Anti-replay to√†n chain |
| `appliedTxHistory` | `List<TxReceipt>` | L·ªãch s·ª≠ giao d·ªãch |
| `l2Commits` | `List<L2Commit>` | *(M5)* Danh s√°ch commit t·ª´ L2 |

### TxReceipt

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `txId` | string | ID giao d·ªãch |
| `status` | enum | Success / Failed |
| `failureReason` | string? | L√Ω do l·ªói |
| `blockHeight` | ulong | Block ch·ª©a tx |
| `stateRootAfter` | string? | *(mock)* State root sau apply |
| `timestamp` | long | Th·ªùi ƒëi·ªÉm x·ª≠ l√Ω |

### L2Commit *(M5)*

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `commitId` | string | ID commit |
| `batchId` | string | ID batch |
| `l2StateRoot` | string | *(mock)* State root L2 sau batch |
| `txCount` | int | S·ªë tx trong batch |
| `txIds` | `List<string>` | *(tu·ª≥ ch·ªçn)* C√≥ th·ªÉ ch·ªâ l∆∞u hash list |
| `submittedAtBlockHeight` | ulong | Block L1 ch·ª©a commit |

### Block

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `height` | ulong | Chi·ªÅu cao |
| `prevHash` | string | Hash block tr∆∞·ªõc |
| `timestamp` | long | Epoch ms |
| `txs` | `List<Tx>` | Danh s√°ch giao d·ªãch |
| `txReceipts` | `List<TxReceipt>` | Bi√™n nh·∫≠n |
| `stateRoot` | string | Mock hash state sau apply |
| `hash` | string | Hash to√†n block |

> **Mock stateRoot/hash**: d√πng hash c·ªßa chu·ªói serialize ƒë√£ sort key ƒë·ªÉ deterministic.

---

## 3) Flow x·ª≠ l√Ω L1 (M4)

### 3.1 Create Tx
- Input: `from`, `to`, `amount`, `nonce`
- T·∫°o `Tx` v·ªõi `chainId`
- `txId = HASH(from|to|amount|nonce|chainId)` ‚Üê deterministic

### 3.2 Sign (mock)
```
signature = SIG(from|to|amount|nonce|chainId)
```

### 3.3 Validate (fail-fast)

| # | Check | Error |
|---|-------|-------|
| 1 | ChainId ƒë√∫ng | `INVALID_CHAIN_ID` |
| 2 | Signature ƒë√∫ng: `signature == expectedMockSig(tx)` | `INVALID_SIGNATURE` |
| 3 | Replay: `tx.txId` ch∆∞a trong `seenTxIds` | `REPLAY_TX` |
| 4 | Account t·ªìn t·∫°i (ho·∫∑c auto-create) | ‚Äî |
| 5 | Nonce ƒë√∫ng: `tx.nonce == accounts[from].nonce` | `INVALID_NONCE` |
| 6 | Balance ƒë·ªß: `accounts[from].balance >= tx.amount` | `INSUFFICIENT_BALANCE` |
| 7 | `amount > 0` v√† `from != to` | `INVALID_AMOUNT` / `SELF_TRANSFER` |

### 3.4 Apply
```
accounts[from].balance -= amount
accounts[to].balance += amount
accounts[from].nonce += 1
```

### 3.5 Update State
- Atomic trong single-thread
- T√≠nh `stateRoot` n·∫øu c·∫ßn snapshot

### 3.6 Append History
```
seenTxIds.add(txId)
TxReceipt(status=SUCCESS, blockHeight=currHeight, ...)
```

### 3.7 Block / Chain History
```
Block(
  height   = prev.height + 1,
  prevHash = prev.hash,
  hash     = HASH(blockHeader + stateRoot + txIds...)
)
‚Üí append v√†o chain: List<Block>
```

---

## 4) M5: Layer 2 gi·∫£ l·∫≠p (t·ªëi thi·ªÉu)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ L2 Mempool‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Off-chain     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Batcher  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Submit to L1  ‚îÇ
‚îÇ nh·∫≠n tx  ‚îÇ     ‚îÇ Execute       ‚îÇ     ‚îÇ gom N tx ‚îÇ     ‚îÇ L2Commit      ‚îÇ
‚îÇ          ‚îÇ     ‚îÇ (same rules)  ‚îÇ     ‚îÇ ‚Üí batch  ‚îÇ     ‚îÇ v√†o ledger    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

1. **L2 Mempool** nh·∫≠n tx (gi·ªëng create/sign/validate s∆° b·ªô)
2. **Execute off-chain**: apply v√†o `l2State` (c√πng rules nonce/balance nh∆∞ L1, ho·∫∑c subset)
3. **Batcher**: m·ªói N tx (ho·∫∑c theo timer):
   - T·∫°o `batchId`
   - T√≠nh `l2StateRoot` (mock)
   - T·∫°o `commitId`
4. **Submit commit to L1**: L1 nh·∫≠n "commit tx" ƒë·ªÉ append `L2Commit` v√†o `ledger.l2Commits` + ghi v√†o block history

> L1 **kh√¥ng** verify cryptography ‚Äî ch·ªâ l∆∞u "d·∫•u v·∫øt" + tham chi·∫øu batch/txCount/roots.

---

## 5) Test Scenarios (5 b·∫Øt bu·ªôc)

### (1) Happy path ‚Äî transfer h·ª£p l·ªá
- **Given**: A(balance=100, nonce=0), B(balance=0)
- **When**: tx(A‚ÜíB, amount=10, nonce=0), sign mock, validate/apply
- **Then**: A(balance=90, nonce=1), B(balance=10), receipt SUCCESS, seenTxIds c√≥ txId, block height tƒÉng, prevHash n·ªëi ƒë√∫ng

### (2) Nonce sai
- **Given**: A(balance=100, nonce=1)
- **When**: tx(A‚ÜíB, amount=10, nonce=0)
- **Then**: fail `INVALID_NONCE`, state kh√¥ng ƒë·ªïi, txId kh√¥ng add v√†o seenTxIds

### (3) Thi·∫øu balance
- **Given**: A(balance=5, nonce=0)
- **When**: tx(A‚ÜíB, amount=10, nonce=0)
- **Then**: fail `INSUFFICIENT_BALANCE`, state kh√¥ng ƒë·ªïi

### (4) Ch·ªØ k√Ω mock sai
- **Given**: tx ƒë√∫ng fields nh∆∞ng signature b·ªã s·ª≠a
- **When**: validate
- **Then**: fail `INVALID_SIGNATURE`, state kh√¥ng ƒë·ªïi

### (5) Replay tx + Chain history
- **Given**: ƒë√£ apply tx1 th√†nh c√¥ng (txId=X) ·ªü block H
- **When**: g·ª≠i l·∫°i ƒë√∫ng tx1 (c√πng fields ‚Üí c√πng txId)
- **Then**: fail `REPLAY_TX`
- **And**: chain history: block m·ªõi ph·∫£i c√≥ `prevHash == hash(block H)`, verify to√†n chain: m·ªói `block.prevHash` kh·ªõp hash block tr∆∞·ªõc, height tƒÉng 1 ƒë·ªÅu

---

## 6) Invariants (B·∫•t bi·∫øn)

- ‚úÖ Nonce ch·ªâ tƒÉng khi tx th√†nh c√¥ng
- ‚úÖ T·ªïng balance to√†n h·ªá (n·∫øu ch·ªâ transfer) kh√¥ng ƒë·ªïi
- ‚úÖ M·ªói txId ch·ªâ ƒë∆∞·ª£c apply t·ªëi ƒëa 1 l·∫ßn trong to√†n chain
- ‚úÖ Chain history kh√¥ng ƒë·ª©t: `(height, prevHash)` li√™n k·∫øt ch√≠nh x√°c