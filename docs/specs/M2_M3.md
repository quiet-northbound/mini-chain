# M2 + M3 Spec ‚Äî Block & Chain History

> **Status**: üî≤ Ch∆∞a implement

---

## 1) M·ª•c ti√™u

| Milestone | M√¥ t·∫£ |
|-----------|--------|
| **M2** | Ho√†n thi·ªán mini Layer1: data model r√µ r√†ng + lu·ªìng tx end-to-end + validate/apply + l∆∞u chain history ·ªïn ƒë·ªãnh |
| **M3** | B·ªï sung block & ledger semantics: gom tx v√†o block, t√≠nh block hash, replay protection + history nh·∫•t qu√°n |

---

## 2) Data Model t·ªëi thi·ªÉu

### 2.1 Account

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `address` | string | ID account |
| `balance` | long | S·ªë d∆∞ coin g·ªëc (integer) |
| `nonce` | long | S·ªë tx ƒë√£ g·ª≠i th√†nh c√¥ng |
| `pubKey` | string? | *(optional)* Mock signature "ƒë√∫ng ng∆∞·ªùi" |

**Invariants:**
- `balance >= 0`
- `nonce >= 0`
- Nonce ch·ªâ tƒÉng khi tx ƒë∆∞·ª£c apply th√†nh c√¥ng

### 2.2 Transaction

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `from` | string | Ng∆∞·ªùi g·ª≠i |
| `to` | string | Ng∆∞·ªùi nh·∫≠n |
| `amount` | long | S·ªë ti·ªÅn chuy·ªÉn |
| `nonce` | long | Nonce m√† sender "mu·ªën d√πng" |
| `chainId` | string | Ch·ªëng replay cross-chain (constant) |
| `signature` | string | Mock signature |

**TxId (deterministic):**
```
txId = hash(from|to|amount|nonce|chainId)
```
> D√πng ƒë·ªÉ detect duplicate/replay trong c√πng chain history.

### 2.3 Ledger / State

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `accounts` | `Map<address, Account>` | B·∫£n ƒë·ªì t√†i kho·∫£n |
| `txHistory` | `List<TxReceipt>` ho·∫∑c `Map<txId, TxReceipt>` | L·ªãch s·ª≠ giao d·ªãch |
| `latestBlockHeight` | long | Chi·ªÅu cao block m·ªõi nh·∫•t |
| `latestBlockHash` | string | Hash block m·ªõi nh·∫•t |

### 2.4 TxReceipt

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `txId` | string | ID giao d·ªãch |
| `status` | enum | `Success` \| `Failed` |
| `error` | string? | L√Ω do l·ªói |
| `blockHeight` | long? | Block ch·ª©a tx (n·∫øu ƒë√£ commit) |
| `appliedAt` | datetime | Th·ªùi ƒëi·ªÉm x·ª≠ l√Ω |

### 2.5 Block *(new in M3)*

| Field | Type | M√¥ t·∫£ |
|-------|------|--------|
| `height` | long | Chi·ªÅu cao block |
| `prevHash` | string | Hash c·ªßa block tr∆∞·ªõc |
| `timestamp` | datetime | Th·ªùi ƒëi·ªÉm t·∫°o block |
| `txIds` | `List<string>` | Danh s√°ch TX trong block |
| `stateRoot` | string | Mock hash c·ªßa state snapshot |
| `blockHash` | string | `hash(height\|prevHash\|timestamp\|txIds\|stateRoot)` |

> **Note**: `stateRoot` mock c√≥ th·ªÉ l√† `hash(sorted(address,balance,nonce))` ho·∫∑c `hash(latestBlockHeight|latestBlockHash|...)`.

---

## 3) Flow x·ª≠ l√Ω

### 3.1 Create Tx
- User ch·ªçn `from`, `to`, `amount`
- L·∫•y `expectedNonce = state.accounts[from].nonce`
- Set `tx.nonce = expectedNonce`
- Set `chainId`

### 3.2 Sign (mock)
```
signature = mockSign(tx, fromSecret)
```
> Quy ∆∞·ªõc: `signature == "SIG:" + hash(txId + fromSecret)`

### 3.3 Validate (fail-fast)

| # | Check | Error Code |
|---|-------|------------|
| 1 | Account t·ªìn t·∫°i (`from` c√≥ trong state) | ‚Äî |
| 2 | Amount h·ª£p l·ªá: `amount > 0` | ‚Äî |
| 3 | Balance ƒë·ªß: `accounts[from].balance >= amount` | `ERR_INSUFFICIENT_BALANCE` |
| 4 | Nonce ƒë√∫ng: `tx.nonce == accounts[from].nonce` | `ERR_INVALID_NONCE` |
| 5 | Signature h·ª£p l·ªá | `ERR_INVALID_SIGNATURE` |
| 6 | Replay: txId ch∆∞a t·ªìn t·∫°i trong txHistory | `ERR_REPLAY_TX` |

### 3.4 Apply
N·∫øu validate pass:
```
accounts[from].balance -= amount
accounts[to].balance += amount     ‚Üê n·∫øu to ch∆∞a t·ªìn t·∫°i: create m·ªõi
accounts[from].nonce += 1
```

### 3.5 Append History
- **Success**: `TxReceipt(status=Success, txId, appliedAt, blockHeight=?)`
- **Failed**: c≈©ng append `TxReceipt(Failed)` ƒë·ªÉ trace ‚Äî **kh√¥ng update state**

### 3.6 Block Commit *(M3)*
M·ªói N tx (ho·∫∑c m·ªói l·∫ßn g·ªçi `commitBlock()`):
```
Block(
  height     = latest + 1,
  prevHash   = latestBlockHash,
  txIds      = [success txIds since last block],
  stateRoot  = calcMockRoot(),
  blockHash  = hash(height|prevHash|timestamp|txIds|stateRoot)
)
```
- Update `latestBlockHeight` / `latestBlockHash`
- G√°n `blockHeight` v√†o receipts t∆∞∆°ng ·ª©ng
- Append block v√†o `chainHistory: List<Block>`

---

## 4) Error Codes

| Code | M√¥ t·∫£ |
|------|--------|
| `ERR_INSUFFICIENT_BALANCE` | Kh√¥ng ƒë·ªß s·ªë d∆∞ |
| `ERR_INVALID_NONCE` | Nonce kh√¥ng kh·ªõp |
| `ERR_INVALID_SIGNATURE` | Ch·ªØ k√Ω sai |
| `ERR_REPLAY_TX` | Giao d·ªãch ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω |
| `ERR_CHAIN_HISTORY_MISMATCH` | `block.prevHash != latestBlockHash` ho·∫∑c height nh·∫£y c√≥c |

---

## 5) Test Scenarios (5 b·∫Øt bu·ªôc)

### (1) Happy path
- **Setup**: A=100, B=0, A.nonce=0
- **Tx**: A‚ÜíB, amount=10, nonce=0, signature ƒë√∫ng
- **Expect**:
  - A.balance=90, B.balance=10, A.nonce=1
  - Receipt Success, txId c√≥ trong history
  - *(n·∫øu commit block)* blockHeight tƒÉng, prevHash ƒë√∫ng

### (2) Nonce sai
- **Setup**: A.nonce=1
- **Tx**: nonce=0 (ho·∫∑c 2)
- **Expect**: fail `ERR_INVALID_NONCE`, balances/nonce kh√¥ng ƒë·ªïi, receipt Failed

### (3) Thi·∫øu balance
- **Setup**: A.balance=5
- **Tx**: amount=10
- **Expect**: fail `ERR_INSUFFICIENT_BALANCE`, state kh√¥ng ƒë·ªïi

### (4) Ch·ªØ k√Ω mock sai
- **Setup**: tx h·ª£p l·ªá nh∆∞ng signature b·ªã s·ª≠a
- **Expect**: fail `ERR_INVALID_SIGNATURE`, state kh√¥ng ƒë·ªïi

### (5) Replay tx + Chain history
- **Replay**: g·ª≠i l·∫°i y h·ªát tx ƒë√£ success (same txId)
  - Expect: fail `ERR_REPLAY_TX`
- **Chain history**: c·ªë commit block v·ªõi prevHash sai ho·∫∑c height nh·∫£y c√≥c
  - Expect: reject `ERR_CHAIN_HISTORY_MISMATCH`, kh√¥ng update latestBlockHash/height